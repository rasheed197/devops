# PROCESSES

### 1. top COMMAND
The top command will show you all the dynamic processes based on their consumption of CPU and RAM.

```
[root@centos ~]# top

top - 04:16:38 up 47 min,  1 user,  load average: 0.00, 0.00, 0.00
...

PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
320 root      20   0       0      0      0 I   0.7   0.0   0:03.34 kworker/1:1-events
4478 root     20   0   10564   4224   3456 R   0.7   0.2   0:00.38 top
4427 vagrant  20   0   20692   7344   5376 S   0.3   0.4   0:00.55 sshd
...
```

It is similar to task manager on Windows

It shows lots of informations like uptime, number of logged in user, load average.

Load average is CPU wait time, it is different from CPU utilization

If CPU utilization is full, then the load average will start increasing.

The load average shows three values separated by comma (,)
```
1. current minute load average
2. last 5 minutes load average
3. last 15 minutes load average
```

Here processes are called as Tasks
```
[root@centos ~]# top

...
Tasks: 118 total,   1 running, 117 sleeping,   0 stopped,   0 zombie
...
```

So we have 
```
- 118 tasks total
- out of them only 1 is running and 117 are sleeping
- 0 are in a stopped state
- 0 zombie processes: zombie processes are processes whose operations are done but their entry is still in the process table
```

```
[root@centos ~]# top

...
%Cpu(s):  0.0 us,  0.2 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
...
```

CPU utilization is 0.0 currently 

```
[root@centos ~]# top

...
MiB Mem :   1774.3 total,   1419.0 free,    278.8 used,    226.8 buff/cache
MiB Swap:   1024.0 total,   1024.0 free,      0.0 used.   1495.5 avail Mem
...
```

And then we have the RAM and Swap details, which is better to see through "free -m" command

```
[root@centos ~]# top

...
PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
320 root      20   0       0      0      0 I   0.7   0.0   0:03.34 kworker/1:1-events
4478 root     20   0   10564   4224   3456 R   0.7   0.2   0:00.38 top
4427 vagrant  20   0   20692   7344   5376 S   0.3   0.4   0:00.55 sshd
...
```

```
- PID: Process ID, every process will have an ID
- USER: The user running the process
- COMMAND: The process names
- S: Process status
    S: Sleeping
    I: Idle
    R: Running
- %CPU: The CPU the process is consuming
- %MEM: The RAM the process is consuming
- TIME+: Total CPU time consumed by the process.
```

#### Press <kbd>q</kbd> to quit the top command

### 2. ps aux COMMAND

It's similar to top, but it displays the information on the screen and it just quits
```
[root@centos ~]# ps aux

USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.1  0.9 109792 18104 ?        Ss   03:29   0:06 /usr/lib/systemd/systemd --switched-root --system --deserialize 31
root           2  0.0  0.0      0     0 ?        S    03:29   0:00 [kthreadd]
root           3  0.0  0.0      0     0 ?        S    03:29   0:00 [pool_workqueue_]
...
root        4506 10.4  0.6  21180 11360 ?        Ss   04:59   0:00 /usr/sbin/httpd -DFOREGROUND
apache      4507  0.0  0.4  23072  7524 ?        S    04:59   0:00 /usr/sbin/httpd -DFOREGROUND
...
```

**PID 1** is the first process which in new linux system is **systemd**, in older linux system is, it's **init**. But in Ubuntu it's still **init**

This **init** process is going to start so many other process and will also handle so many other child processes.

The processes that you see in [] are kernel threads

If you scroll down, we also have some normal processes like httpd process.

You see multiple httpd processes because httpd is running. systemctl started httpd, which started these processes.

### 3. ps -ef COMMAND

This also shows all the processes as well

It will show you not the CPU and RAM utilization but the parent process ID (PPID)

The parent process is the process that started the other process.

So **PPID 0** started **PID 1**

```
[root@centos ~]# ps -ef

UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 03:29 ?        00:00:06 /usr/lib/systemd/systemd --switched-root --system --deserialize 31
root           2       0  0 03:29 ?        00:00:00 [kthreadd]
root           3       2  0 03:29 ?        00:00:00 [pool_workqueue_]
...
root        4506       1  0 04:59 ?        00:00:01 /usr/sbin/httpd -DFOREGROUND
apache      4507    4506  0 04:59 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND
apache      4508    4506  0 04:59 ?        00:00:03 /usr/sbin/httpd -DFOREGROUND
...
```

We don't see **PID 0** because it's dead, it's at the boot time.

If you scroll down, you'll see httpd process.

We can say the **root httpd** process started the all the other **apache httpd** processses beacuse the PPID of the **apache httpd** is 4506 which is the PID of the **root httpd**.

When a parent processs starts a child process, it's called as **FORKING**

We can stop the 4506 process using the **systemctl** or the **kill** command

The 4505 process will first close all its child processes and then it will close itself

```
[root@centos ~]# kill 4506
```

Sometimes process becomes adamant and it does not listen and you have to forcefully kill it with **kill -9**

```
[root@centos ~]# kill -9 4506
```

This command will forcefully kill the parent process, making the child process orphan because the parent process had no idea it's getting closed

```
[root@centos ~]# ps -ef

UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 03:29 ?        00:00:06 /usr/lib/systemd/systemd --switched-root --system --deserialize 31
root           2       0  0 03:29 ?        00:00:00 [kthreadd]
root           3       2  0 03:29 ?        00:00:00 [pool_workqueue_]
...

apache      4507       1  0 04:59 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND
apache      4508       1  0 04:59 ?        00:00:03 /usr/sbin/httpd -DFOREGROUND
apache      4509       1  0 04:59 ?        00:00:06 /usr/sbin/httpd -DFOREGROUND
```

Now, you see these processes are adopted by the systemd process, the first process, and these are orphan processes.

Orphan processes will not serve much purpose but it will still consume the resources.

Nowadays the systems are smart, this orphan process will get cleared out automatically, but if it does not get cleared you have to kill all these processes.

If there are many of these orphan processes it will be difficult to clear all of them using only the kill command.

### Kill the orphan processes all at once

#### Step 1 Get the orphan processes ID
```
[root@centos ~]# ps -ef | grep 'httpd' | grep -v 'grep' | awk '{print $2}'

4507
4508
4509
```

#### Step 2 Pass the PIDs as arguments to the kill command
```
[root@centos ~]# ps -ef | grep 'httpd' | grep -v 'grep' | awk '{print $2}' | xargs kill -9
```

#### THE ZOMBI PROCESS

The zombi process are easy to identify they will have satatus as **Z** in the **ps aux** command.

You can also see the number of zombi processess there are
```
[root@centos ~]# top

...
Tasks: 118 total,   1 running, 117 sleeping,   0 stopped,   0 zombie
...
```

As the name says, zombi, dead, like we see in the movies. Process which is dead, but itsentry still in the process table. It is not consuming resource but it may create some problems.

The best way to clear zombi process is to reboot your machine, but there are some other ways to refresh your process table also.