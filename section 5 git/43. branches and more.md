# BRANCHES AND MORE

Branches are a concept where if you have a team of developers who are working on different features and you don't want to disturb the stable copy of the code (the main branch). If there's any new change that is going to be done by a developer, you can create a new branch will be a copy of the main branch, make the changes, and if everything is okay you can then merge it with the main branch.

Create a branch called "sprint1"
```
$ git branch -c sprint1
```

List all branches
```
$ git branch -a

* main
  sprint1
  remotes/origin/HEAD -> origin/main
  remotes/origin/main
```

list all the files present in "main"
```
HP@DESKTOP-OMEFLDD MINGW64 /c/gitrepos/titanwork (main)
$ ls

jupiter/  nebula/  pluto/       ...     saturn7.py  saturn8.py  saturn9.py
```

Switch to branch "sprint1"
```
$ git checkout sprint1 #OR git switch sprint1

Switched to branch 'sprint1'
Your branch is up to date with 'origin/main'.

HP@DESKTOP-OMEFLDD MINGW64 /c/gitrepos/titanwork (sprint1)
```

List all the files present in "swift1" branch. You will see it's the exact copy of "main" branch
```
HP@DESKTOP-OMEFLDD MINGW64 /c/gitrepos/titanwork (sprint1)
$ ls

jupiter/  nebula/  pluto/       ...     saturn7.py  saturn8.py  saturn9.py
```
### MAKE SOME CHANGES IN BRANCH "sprint1"
Remove some file using "git rm". This will remove the file and also remove it from the index (staging area)
```
HP@DESKTOP-OMEFLDD MINGW64 /c/gitrepos/titanwork (sprint1)
$ git rm saturn6.py  saturn7.py saturn8.py  saturn9.py

rm 'saturn6.py'
rm 'saturn7.py'
rm 'saturn8.py'
rm 'saturn9.py'
```

Check the status. You will see that it's telling us to commit, that means it has already removed it from the index
```
HP@DESKTOP-OMEFLDD MINGW64 /c/gitrepos/titanwork (sprint1)
$ git status

On branch sprint1
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        deleted:    saturn6.py
        deleted:    saturn7.py
        deleted:    saturn8.py
        deleted:    saturn9.py
...
```
Rename a file
```
HP@DESKTOP-OMEFLDD MINGW64 /c/gitrepos/titanwork (sprint1)
$ git mv saturn1.py saturn11.py

HP@DESKTOP-OMEFLDD MINGW64 /c/gitrepos/titanwork (sprint1)
$ ls

jupiter/  nebula/  pluto/  saturn10.py  saturn11.py  saturn2.py  saturn3.py  saturn4.py  saturn5.py
```

remove some more files
```
HP@DESKTOP-OMEFLDD MINGW64 /c/gitrepos/titanwork (sprint1)
$ git rm saturn2.py  saturn3.py saturn4.py  saturn5.py

rm 'saturn2.py'
rm 'saturn3.py'
rm 'saturn4.py'
rm 'saturn5.py'
```

Create some new files
```
HP@DESKTOP-OMEFLDD MINGW64 /c/gitrepos/titanwork (sprint1)
$ touch jupiter{1..4}.rb

HP@DESKTOP-OMEFLDD MINGW64 /c/gitrepos/titanwork (sprint1)
$ ls

jupiter/  jupiter1.rb  jupiter2.rb  jupiter3.rb  jupiter4.rb    ...     saturn5.py
```

Add and commit the changes
```
$ git add .

$ git commit -m "jupiter changes"
```

Now the changes is done on the sprint1 branch not on the main branch. So the push is going to be on "origin sprint1". So that's what origin is, you mention the branch.
```
HP@DESKTOP-OMEFLDD MINGW64 /c/gitrepos/titanwork (sprint1)
$ git push origin sprint1
```

Now there should be a new branch in GitHub.

You can also create a branch from GitHub (e.g sprint2) and pull it into your local repo
```
$ git pull
```

Checkout the new branch "sprint2"
```
$ Git checkout sprint2
```

Make changes to branch "sprint2" and commit changes
```
$ touch sun earth venus moon

$ git add .

$ git commit -m "planet and stars"
```

Merge all changes from sprint1 to main branch. 
```
$ git switch main

$ git merge sprint1
```

After runing the command it will open up vim editor with a default merge message, if you like you can edit it, else just save and quit. 

Now main branch will be same as sprint1 branch.

You can also push all branches at once to the remote repo

```
git push --all origin
```





